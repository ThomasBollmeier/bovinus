#! coding=UTF-8

# Copyright 2012 Thomas Bollmeier <tbollmeier@web.de>

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from bovinus.parsergen.output import AbstractCodeGenerator
from bovinus.parsergen.edit_sections import EditableSections
from bovinus.parsergen.ast import Multiplicity
from bovinus.parsergen.meta_objects import TokenType, Grammar

class PHPCodeGenerator(AbstractCodeGenerator):
    
    VAR_ALL_TOKEN_TYPES = "all_token_types"
    
    def __init__(self, prefix=""):
        
        AbstractCodeGenerator.__init__(self, PHPEditableSections())
        self._enable_token_type_sorting(False)
        
        self._first_token_def = True
        self._prefix = prefix
        if not self._prefix:
            self._var_all_token_types = "$" + self.VAR_ALL_TOKEN_TYPES
        else:
            self._var_all_token_types = "$" + self._prefix + "_" + self.VAR_ALL_TOKEN_TYPES
        
    def _start_code_creation(self):
        
        return ["<?php"]

    def _create_default_comment(self):
        
        res = []
        self._add(res)
        self._add(res, "/*")
        self._add(res, "* This file has been generated by Bovinus from a grammar file.")
        self._add(res, "* (See http://bovinus.bollmeier.de for details)")
        self._add(res, "* All changes outside of editable sections will be overwritten.")
        self._add(res, "*/")
        self._add(res)
                
        return res

    def _create_top_section(self, symbols):

        res = []
        self._insert_editable_section(res,
                                      "namespace",
                                      ["// Insert namespace definition here..."]
                                      )
        self._add(res, "require_once 'Bovinus/parser.php';")
        self._add(res)
        self._insert_editable_section(res, "init")
        
        return res        
    
    def _create_single_parser_code(self, grammar, symbols):
        
        res = []
        
        parserClassName = self._to_upcase_after_underscore(grammar.rule_id)
        if self._prefix:
            parserClassName = self._prefix + "_" + parserClassName
        
        self._add(res, "class %s_Parser extends Bovinus_Parser {" % parserClassName)
        self._add(res)
        
        self._indent()
        self._add(res, "public function __construct() {")
        
        self._indent()
        self._add(res)
        self._add(res, "parent::__construct(new %s());" % self._rule_class_name(grammar))
        self._add(res)
        line_comment = symbols.get_line_comment()
        if line_comment:
            self._add(res, "$this->enableLineComments(%s);" % line_comment)  
        block_comment = symbols.get_block_comment()
        if block_comment:
            self._add(res, "$this->enableBlockComments(%s, %s);" % block_comment)
        fbt_enabled = symbols.is_full_backtracking_enabled()
        if fbt_enabled:
            self._add(res, "$this->enableFullBacktracking(TRUE);")
        if line_comment or block_comment or fbt_enabled:
            self._add(res)
        self._dedent()
        
        self._add(res, "}")
        
        self._dedent()
        self._add(res, "}")        
        
        return res
    
    def _create_token_type_def(self, ttype):

        res = []
        
        if self._first_token_def:
            self._add(res, "// ========== Private section ==========")
            self._add(res)
            self._add(res, self._var_all_token_types + " = array();")
            self._add(res)
            self._first_token_def = False
            
        name = self._token_type_name(ttype)

        if ttype.token_type == TokenType.KEYWORD:
            tmp = self._to_bool_str(ttype.case_sensitive)
            line = "$%s = new Bovinus_Keyword('%s', %s);" % (name, ttype.text, tmp)
            self._add(res, line) 
        elif ttype.token_type == TokenType.WORD:
            line = "$%s = new Bovinus_Word('%s');" % (name, ttype.text)
            self._add(res, line)
        elif ttype.token_type == TokenType.PREFIX:
            tmp = self._to_bool_str(ttype.escape)
            line = "$%s = new Bovinus_Prefix('%s', %s);" % (name, ttype.text, tmp)
            self._add(res, line)
        elif ttype.token_type == TokenType.POSTFIX:
            tmp = self._to_bool_str(ttype.escape)
            line = "$%s = new Bovinus_Postfix('%s', %s);" % (name, ttype.text, tmp)
            self._add(res, line)
        elif ttype.token_type == TokenType.SEPARATOR:
            if not ttype.is_pattern:
                ws_allowed = self._to_bool_str(ttype.whitespace_allowed)
                escape = self._to_bool_str(ttype.escape)
                line = "$%s = new Bovinus_Separator('%s', %s, %s);" % \
                (name, ttype.text, ws_allowed, escape)
            else:
                line = "$%s = Bovinus_Separator::create('%s');" % (name, ttype.text)
            self._add(res, line)
        elif ttype.token_type == TokenType.LITERAL:
            line = "$%s = Bovinus_Literal::get();" % name
            self._add(res, line)
        else:
            raise Exception("Unknown token type")
        
        self._add(res, "array_push(%s, $%s);" % (self._var_all_token_types, name))
        self._add(res)
        
        return res
        
    def _create_rule_begin(self, rule):
        
        res = []
        
        is_grammar = isinstance(rule, Grammar)

        name = self._rule_class_name(rule)
        
        if not is_grammar:
            self._add(res, "class %s extends Bovinus_Rule {" % name)
        else:
            self._add(res, "class %s extends Bovinus_Grammar {" % name)
        self._add(res)

        self._indent()

        if not is_grammar:
            self._add(res, 'public function __construct($identifier="") {')
            self._add(res)
            self._indent()
            self._add(res, "parent::__construct('%s', $identifier);" % rule.rule_id)
        else:
            self._add(res, "public function __construct() {")
            self._add(res)
            self._indent()
            self._add(res, "global %s;" % self._var_all_token_types)
            self._add(res)
            self._add(res, "parent::__construct('%s', %s);" % (name, self._var_all_token_types))

        self._add(res)
        self._dedent()
        self._add(res, "}")
        self._add(res)
                
        return res

    def _create_rule_expand_method(self, top_branch_names):
        
        res = []
        self._add(res, "public function expand($start, $end, $context) {")
        self._indent()
        
        self._add(res)
        for name in top_branch_names:
            self._add(res, "$start->connect($this->%s())->connect($end);" % name)
        self._add(res)
                
        self._dedent()
        self._add(res, "}")
        self._add(res)

        return res

    def _create_rule_transform_method(self, rule):
        
        res = []
        self._add(res, "public function transform($astNode) {")
        self._indent()

        self._add(res)
        
        section_name = "%s-transform" % rule.rule_id
        default_lines = ["", "return $astNode;", ""]

        self._insert_editable_section(res, section_name, default_lines)
        
        self._dedent()
        self._add(res, "}")
        self._add(res)
                
        return res
    
    def _create_sequence_code(self, name, subrule_names):
        
        res = []
        
        self._add(res, "private function %s() {" % name)
        self._indent()
        self._add(res)
        
        num_subrules = len(subrule_names)
        
        if num_subrules != 1:
            self._add(res, "$elements = array();")
            for subrule_name in subrule_names:
                self._add(res, "array_push($elements, $this->%s());" % subrule_name)
            self._add(res)
            self._add(res, "return new Bovinus_Sequence($elements);")
        else:
            self._add(res, "return $this->%s();" % subrule_names[0])
            
        self._add(res)
        self._dedent()
        self._add(res, "}")
        self._add(res)
        
        return res
                
    def _create_fork_code(self, name, subrule_names, multiplicity):
        
        res = []
        
        self._add(res, "private function %s() {" % name)
        self._indent()
        self._add(res)
        
        num_subrules = len(subrule_names)
        
        if num_subrules != 1:
            self._add(res, "$branches = array();")
            for subrule_name in subrule_names:
                self._add(res, "array_push($branches, $this->%s());" % subrule_name)
            self._add(res)
            result_str = "new Bovinus_Fork($branches)"
        else:
            result_str = "$this->%s()" % subrule_names[0]
            
        result_str = self._result_with_mult(result_str, multiplicity)
                    
        self._add(res, "return %s;" % result_str)
        self._add(res)
        self._dedent()
        self._add(res, "}")
        self._add(res)
        
        return res
    
    def _create_subrule_code(self, name, rule, element_id, multiplicity):
        
        res = []
        
        self._add(res, "private function %s() {" % name)
        self._indent()
        self._add(res)
        result_str = "new %s(" % self._rule_class_name(rule)
        if element_id:
            result_str += "'%s'" % element_id
        result_str += ')'
        result_str = self._result_with_mult(result_str, multiplicity)
        self._add(res, "return " + result_str + ";")
        self._add(res)
        self._dedent()
        self._add(res, "}")
        self._add(res)
        
        return res

    def _create_token_type_code(self, name, token_type, element_id, multiplicity):
        
        res = []
        
        ttype_name = self._token_type_name(token_type)
        
        self._add(res, "private function %s() {" % name)
        self._indent()
        self._add(res)
        self._add(res, "global $%s;" % ttype_name)
        self._add(res)
        result_str = "bovinus_tokenNode($%s" % ttype_name
        if element_id:
            result_str += ", '%s'" % element_id
        result_str += ')'
        result_str = self._result_with_mult(result_str, multiplicity)
        self._add(res, "return " + result_str + ";")
        self._add(res)
        self._dedent()
        self._add(res, "}")
        self._add(res)
        
        return res

    def _create_rule_end(self, rule):
        
        res = []
        
        section_name = "%s-further-private-methods" % rule.rule_id
        default_lines = ["", "// add your methods here...", ""]

        self._insert_editable_section(res, section_name, default_lines)
        
        self._dedent()
        self._add(res, "}")
        self._add(res)
        
        return res

    def _create_bottom_section(self, symbols):

        res = []
        self._add(res, "?>")
        
        return res
    
    def _token_type_name(self, token_type):
        
        res = token_type.token_id
        if self._prefix:
            res = self._prefix + "_" + res
            
        return res
    
    def _rule_class_name(self, rule):
        
        res = self._to_upcase_after_underscore(rule.rule_id) 
        if self._prefix:
            res = self._prefix + "_" + res
            
        if not isinstance(rule, Grammar):
            res += "_Rule"
        else:
            res += "_Grammar"
            
        res = "_" + res
            
        return res
    
    def _to_upcase_after_underscore(self, name):
        
        res = ""
        
        prev = ""
        for ch in name:
            if prev:
                if prev not in ['-', '_']:
                    res += ch
                else:
                    res += ch.upper()
            else:
                res += ch.upper()
            prev = ch
            
        return res

    def _result_with_mult(self, res_str, mult):

        if mult == Multiplicity.ZERO_TO_ONE:
            return "bovinus_zero_to_one(%s)" % res_str
        elif mult == Multiplicity.ZERO_TO_MANY:
            return "bovinus_zero_to_many(%s)" % res_str
        elif mult == Multiplicity.ONE_TO_MANY:
            return "bovinus_one_to_many(%s)" % res_str
        else:
            return res_str
        
    def _to_bool_str(self, value):
        
        if value:
            return "TRUE"
        else:
            return "FALSE"

class PHPEditableSections(EditableSections):

    def __init__(self):

        EditableSections.__init__(
            self,
            r"\s*//\s+edit-section\s+([\w\-]+)\s+{\s*",
            r"\s*//\s+}\s+edit-section-end\s*"
            )

    def _create_section_begin(self, section_name):

        return "// edit-section %s {" % section_name

    def _create_section_end(self, section_name):

        return "// } edit-section-end"
