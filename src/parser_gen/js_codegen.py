#! coding=UTF-8

# Copyright 2012 Thomas Bollmeier <tbollmeier@web.de>

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#   http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from bovinus.parsergen.output import AbstractCodeGenerator
from bovinus.parsergen.edit_sections import EditableSections
from bovinus.parsergen.ast import Multiplicity
from bovinus.parsergen.meta_objects import TokenType, Grammar

class JSCodeGenerator(AbstractCodeGenerator):
    """
    code generator for JavaScript parsers
    """
    
    VAR_ALL_TOKEN_TYPES = "all_token_types"
    
    def __init__(self):
        
        AbstractCodeGenerator.__init__(self, JSEditableSections())
        
        self._enable_token_type_sorting(False)
        self._first_token_def = True
        
    def _create_default_comment(self):
        
        res = []
        self._add(res, "/*")
        self._add(res, "* This file has been generated by Bovinus from a grammar file.")
        self._add(res, "* (See http://bovinus.bollmeier.de for details)")
        self._add(res, "* All changes outside of editable sections will be overwritten.")
        self._add(res, "*/")
        self._add(res)
        
        return res

    def _create_top_section(self, symbols):

        res = []
        
        grammar = symbols.get_grammar()
        
        self._add(res, "var %s = {};" % self._to_camel_case(grammar.rule_id))
        self._add(res)
        self._add(res, "(function(imports, exports) {")
        self._indent()
        self._add(res)
        self._add(res, '"use strict";')
        self._add(res)
        self._add(res, "var OOPtimus = imports.OOPtimus;")
        self._add(res, "var bovinus = imports.bovinus;")
        self._add(res)
        self._insert_editable_section(res, "init")
        
        return res        
    
    def _create_single_parser_code(self, grammar, symbols):
        
        res = []
                
        self._add(res, "var Parser = OOPtimus.defClass(bovinus.Parser, function() {")
        self._indent()
        self._add(res)
        self._add(res, "this.superInit(new %s());" % self._rule_class_name(grammar))
        self._add(res)
        line_comment = symbols.get_line_comment()
        if line_comment:
            self._add(res, "this.enableLineComments(%s);" % line_comment)  
        block_comment = symbols.get_block_comment()
        if block_comment:
            self._add(res, "this.enableBlockComments(%s, %s);" % block_comment)
        bt = symbols.is_full_backtracking_enabled()
        if bt:
            self._add(res, "this.enableFullBacktracking(true);")
        if line_comment or block_comment or bt:
            self._add(res)  
        self._dedent()
        self._add(res, "});")
        self._add(res)

        return res
    
    def _create_token_type_def(self, ttype):

        res = []
        
        if self._first_token_def:
            self._add(res, "/* ========== Private section ========== */")
            self._add(res)
            self._add(res, "var %s = [];" % self.VAR_ALL_TOKEN_TYPES)
            self._add(res)
            self._first_token_def = False

        if ttype.token_type == TokenType.KEYWORD:
            case_sensitive_str = ttype.case_sensitive and 'true' or 'false'
            line = "var %s = new bovinus.Keyword('%s', %s);" % (ttype.token_id, ttype.text, case_sensitive_str)
        elif ttype.token_type == TokenType.WORD:
            line = "var %s = new bovinus.Word('%s');" % (ttype.token_id, ttype.text)
        elif ttype.token_type == TokenType.PREFIX:
            escape_str = ttype.escape and 'true' or 'false'
            line = "var %s = new bovinus.Prefix('%s', %s);" % (ttype.token_id, ttype.text, escape_str)
        elif ttype.token_type == TokenType.POSTFIX:
            escape_str = ttype.escape and 'true' or 'false'
            line = "var %s = new bovinus.Postfix('%s', %s);" % (ttype.token_id, ttype.text, escape_str)
        elif ttype.token_type == TokenType.SEPARATOR:
            if not ttype.is_pattern:
                ws_allowed_str = ttype.whitespace_allowed and 'true' or 'false'
                escape_str = ttype.escape and 'true' or 'false'
                line = "var %s = new bovinus.Separator('%s', %s, %s);" % \
                (ttype.token_id, ttype.text, ws_allowed_str, escape_str)
            else:
                line = "var %s = bovinus.Separator.create('%s');" % (ttype.token_id, ttype.text)
        elif ttype.token_type == TokenType.LITERAL:
            line = "var %s = bovinus.Literal.get();" % ttype.token_id
        else:
            raise Exception("Unknown token type")
        
        self._add(res, line)
        
        self._add(res, "%s.push(%s);" % (self.VAR_ALL_TOKEN_TYPES, ttype.token_id))
        self._add(res)
        
        return res
        
    def _create_rule_begin(self, rule):
        
        res = []
        
        self._curRuleClass = self._rule_class_name(rule)
        
        is_grammar = isinstance(rule, Grammar)
        
        if not is_grammar:
            self._add(res, "var %s = bovinus.define_rule('%s', {" % (self._rule_class_name(rule), rule.rule_id))
        else:
            self._add(res, "var %s = bovinus.define_grammar(%s, {" % (self._rule_class_name(rule), self.VAR_ALL_TOKEN_TYPES))
        self._indent()
        self._add(res)
        res += self._add_expand_function(rule)
        res += self._add_transform_function(rule)

        self._dedent()
        self._add(res, "});")
        self._add(res)

        section_name = "%s-user-defined-methods" % rule.rule_id
        sample_line = "// %s.addMember(\"myMethod\", function(arg1, ...) {...});" % self._rule_class_name(rule)
        default_lines = ["", sample_line, ""]
        self._insert_editable_section(res, section_name, default_lines)

        self._add(res)

        return res
    
    def _add_expand_function(self, rule):
        
        res = []
        
        self._add(res, "expand: function(start, end, context) {")
        self._indent()
        self._add(res)
        for idx in range(len(rule.branches)):
            name = self._subrule_name([idx])
            self._add(res, "start.connect(this.%s()).connect(end);" % name)
        self._add(res)
        self._dedent()
        self._add(res, "},")
        
        return res

    def _add_transform_function(self, rule):
        
        res = []
        
        self._add(res, "transform: function(astNode) {")
        self._indent()
        self._add(res)

        section_name = "%s-transform" % rule.rule_id
        default_lines = ["", "return astNode;", ""]
        self._insert_editable_section(res, section_name, default_lines)
        
        self._dedent()
        self._add(res, "}")
        
        return res

    def _create_rule_expand_method(self, top_branch_names):
        
        return []

    def _create_rule_transform_method(self, rule):
        
        return []
    
    def _create_sequence_code(self, name, subrule_names):
        
        res = []
        
        self._add(res, "%s.addMember('%s', function() {" % (self._curRuleClass, name))
        self._indent()
        self._add(res)
        
        num_subrules = len(subrule_names)
        
        if num_subrules != 1:
            self._add(res, "return bovinus.sequence(")
            self._indent()
            line = "" 
            for subrule_name in subrule_names:
                if line:
                    self._add(res, line + ",")
                line = "this.%s()" % subrule_name
            if line:
                self._add(res, line)
            self._dedent()
            self._add(res, ");")
        else:
            self._add(res, "return this.%s();" % subrule_names[0])
            
        self._add(res)
        self._dedent()
        self._add(res, "});")
        self._add(res)
        
        return res
                
    def _create_fork_code(self, name, subrule_names, multiplicity):
        
        res = []

        self._add(res, "%s.addMember('%s', function() {" % (self._curRuleClass, name))
        self._indent()
        self._add(res)
        
        num_subrules = len(subrule_names)
        
        if num_subrules != 1:
            self._add(res, "var res = bovinus.fork(")
            self._indent()
            line = "" 
            for subrule_name in subrule_names:
                if line:
                    self._add(res, line + ",")
                line = "this.%s()" % subrule_name
            if line:
                self._add(res, line)
            self._dedent()
            self._add(res, ");")
        else:
            self._add(res, "var res = this.%s();" % subrule_names[0])
            
        if multiplicity != Multiplicity.NONE:
            self._add(res, "res = %s;" % self._result_with_mult("res", multiplicity))
        self._add(res, "return res;")
        self._add(res)
        self._dedent()
        self._add(res, "});")
        self._add(res)
        
        return res
    
    def _create_subrule_code(self, name, rule, element_id, multiplicity):

        res = []

        self._add(res, "%s.addMember('%s', function() {" % (self._curRuleClass, name))
        self._indent()
        self._add(res)

        result_str = "new %s(" % self._rule_class_name(rule)
        if element_id:
            result_str += "'%s'" % element_id
        result_str += ')'
        result_str = self._result_with_mult(result_str, multiplicity)
        self._add(res, "return %s;" % result_str)
        self._add(res)
        self._dedent()
        self._add(res, "});")
        self._add(res)
        
        return res

    def _create_token_type_code(self, name, token_type, element_id, multiplicity):
        
        res = []

        self._add(res, "%s.addMember('%s', function() {" % (self._curRuleClass, name))
        self._indent()
        self._add(res)

        result_str = "bovinus.tnode(%s" % token_type.token_id
        if element_id:
            result_str += ", '%s'" % element_id
        result_str += ')'
        result_str = self._result_with_mult(result_str, multiplicity)
        self._add(res, "return %s;" % result_str)
        self._add(res)
        self._dedent()
        self._add(res, "});")
        self._add(res)

        return res

    def _create_rule_end(self, rule):
        
        self._curRuleClass = ""
        
        return []

    def _create_bottom_section(self, symbols):
        
        res = []
        
        grammar = symbols.get_grammar()
        module_name = self._to_camel_case(grammar.rule_id)

        self._add(res, "exports.Parser = Parser;")
        self._add(res)
        self._dedent()        
        self._add(res, "}({")
        self._indent()
        self._add(res, '"OOPtimus": OOPtimus,')
        self._add(res, '"bovinus": bovinus')
        self._dedent()
        self._add(res, "},")
        self._add(res, module_name)
        self._add(res, "));")
        self._add(res)
        
        return res
    
    def _rule_class_name(self, rule):
        
        res = self._to_camel_case(rule.rule_id)
            
        if not isinstance(rule, Grammar):
            res += "Rule"
        else:
            res += "Grammar"
            
        res = "_" + res
            
        return res
    
    def _to_camel_case(self, name):
        
        res = ""
        
        prev = ""
        for ch in name:
            if prev:
                if ch not in ['-', '_']:
                    if prev not in ['-', '_']:
                        res += ch
                    else:
                        res += ch.upper()
            else:
                res += ch.upper()
            prev = ch
            
        return res

    def _result_with_mult(self, res_str, mult):

        if mult == Multiplicity.ZERO_TO_ONE:
            return "bovinus.zero_to_one(%s)" % res_str
        elif mult == Multiplicity.ZERO_TO_MANY:
            return "bovinus.zero_to_many(%s)" % res_str
        elif mult == Multiplicity.ONE_TO_MANY:
            return "bovinus.one_to_many(%s)" % res_str
        else:
            return res_str

class JSEditableSections(EditableSections):

    def __init__(self):

        EditableSections.__init__(
            self,
            r"\s*/\*\s+edit-section\s+([\w\-]+)\s+{\s*\*/",
            r"\s*/\*\s+}\s+edit-section-end\s*\*/"
            )

    def _create_section_begin(self, section_name):

        return "/* edit-section %s { */" % section_name

    def _create_section_end(self, section_name):

        return "/* } edit-section-end */"
